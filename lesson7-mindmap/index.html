<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mindmap Webapp</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        .top-bar {
            background-color: #ffffff;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            border-bottom: 1px solid #e0e0e0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            z-index: 100;
        }

        .top-bar .menu-icon { font-size: 24px; cursor: pointer; margin-right: 15px; }
        .top-bar .title { font-size: 18px; font-weight: 600; color: #333; margin-right: auto; }
        .top-bar .user-avatar { width: 32px; height: 32px; border-radius: 50%; background-color: #ffbf00; color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; margin-right: 10px; }
        .top-bar .share-btn { background-color: #4A4AFF; color: white; padding: 8px 15px; border: none; border-radius: 5px; cursor: pointer; font-weight: 500; display: flex; align-items: center; }
        .top-bar .share-btn:hover { background-color: #3a3acc; }
        .top-bar .action-icons { margin-left: 20px; display: flex; gap: 15px; }
        .top-bar .action-icons span { font-size: 20px; cursor: pointer; color: #555; }
        .top-bar .action-icons span:hover { color: #000; }

        .main-content {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            background-color: #E9EBF8;
            cursor: grab;
        }
        .main-content.panning { cursor: grabbing; }

        #mindmap-container {
            position: absolute;
            width: 4000px; 
            height: 3000px; 
            transform-origin: 0 0;
        }

        .node {
            position: absolute;
            background-color: #fff;
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 13px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            cursor: pointer;
            min-width: 100px;
            max-width: 250px;
            text-align: center;
            line-height: 1.4;
            user-select: none;
            z-index: 1; 
            /* Modified transition: be more specific or use the dragging class to override */
            transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out, border 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            border: 2px solid transparent;
        }
        .node.node-highlighted {
            border: 4px solid #4A4AFF;
            box-shadow: 0 0 0 2px rgba(74, 74, 255, 0.3);
            z-index: 5;
        }
        .node.node-selected {
            border: 4px solid #4A4AFF;
            box-shadow: 0 0 0 4px rgba(74, 74, 255, 0.3);
            z-index: 10;
        }
        /* NEW CLASS TO HANDLE DRAGGING STATE */
        .node.node-dragging-active {
            transition: none !important; /* Crucial: disable transition for left/top during drag */
            z-index: 1000 !important; /* Optional: ensure dragged node is visually on top */
             box-shadow: 0 8px 20px rgba(0,0,0,0.25); /* Optional: visual feedback for dragging */
        }

        .node .node-content-wrapper { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
        }
        .node .node-text { margin-bottom: 5px; font-weight: bold; }
        .node .magic-icon {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 16px;
            cursor: pointer;
            color: #FFD700;
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            padding: 2px;
            z-index: 1; 
        }
        .node .magic-icon:hover { color: #FFA500; }

        .node-toggle {
            position: absolute;
            right: -10px; 
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            background-color: #fff;
            border: 1.5px solid #7f8c8d;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px; 
            font-weight: bold;
            color: #555;
            cursor: pointer;
            z-index: 5; 
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .node-toggle:hover {
            background-color: #f0f0f0;
            border-color: #333;
        }

        #mindmap-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%; 
            height: 100%; 
            pointer-events: none;
            z-index: 0; 
        }
        #mindmap-svg path {
            stroke-width: 1.5px;
            fill: none;
            transition: stroke-width 0.2s ease-in-out, stroke 0.2s ease-in-out, filter 0.2s ease-in-out; 
            pointer-events: stroke;
            cursor: pointer;
        }
        #mindmap-svg path.path-highlighted {
            stroke-width: 3px;
            stroke: #4A4AFF !important;
            filter: drop-shadow(0 0 5px rgba(74, 74, 255, 0.6));
        }
        #mindmap-svg path.path-selected {
            stroke-width: 3px;
            stroke: #FF4A4A !important;
            filter: drop-shadow(0 0 5px rgba(255, 74, 74, 0.6));
        }


        .bottom-toolbar {
            background-color: #ffffff;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            border-top: 1px solid #e0e0e0;
            box-shadow: 0 -2px 4px rgba(0,0,0,0.05);
            z-index: 100;
        }
        .bottom-toolbar .dropdown, .bottom-toolbar .zoom-level-display { padding: 8px 12px; border: 1px solid #ddd; border-radius: 5px; margin-right: 15px; font-size: 14px; background-color: #f9f9f9; }
        .bottom-toolbar .zoom-level-display { width: 60px; text-align: center; }
        .bottom-toolbar .tools { display: flex; gap: 10px; margin-left: auto; }
        .bottom-toolbar .tool-btn { background-color: #f0f0f0; border: 1px solid #ccc; color: #333; padding: 8px; border-radius: 5px; cursor: pointer; font-size: 18px; width: 38px; height: 38px; display: flex; align-items: center; justify-content: center; }
        .bottom-toolbar .tool-btn:hover { background-color: #e0e0e0; }

        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5); align-items: center; justify-content: center; }
        .modal-content { background-color: #fefefe; margin: auto; padding: 30px; border: 1px solid #888; width: 60%; max-width: 700px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); position: relative; }
        .modal-content h2 { margin-top: 0; color: #333; border-bottom: 1px solid #eee; padding-bottom: 10px; margin-bottom: 20px; }
        .modal-content label { display: block; margin-bottom: 5px; font-weight: bold; color: #555; }
        .modal-content input[type="text"], .modal-content textarea { width: 95%; padding: 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 14px; margin-bottom: 15px; }
        .modal-content textarea { resize: vertical; }
        .modal-content .chat-area { width: 95%; border: 1px solid #ccc; border-radius: 5px; padding: 10px; margin-bottom: 10px; overflow-y: auto; background-color: #f9f9f9; font-size:14px; line-height: 1.5;}
        .modal-content .chat-area p { margin: 5px 0; }
        .modal-content .modal-buttons { text-align: right; margin-top: 10px; }
        .modal-content button { background-color: #4A4AFF; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; margin-left: 10px; }
        .modal-content button.cancel-btn { background-color: #ccc; color: #333; }
        .modal-content button:hover { opacity: 0.9; }
        .close-btn { position: absolute; top: 15px; right: 20px; color: #aaa; font-size: 28px; font-weight: bold; cursor: pointer; }
        .close-btn:hover, .close-btn:focus { color: black; text-decoration: none; }

        .node.level-0 {
            width: 320px !important;
            height: 90px !important;
            font-size: 1.5em;
            background: #1a237e;
            color: #fff;
            font-weight: bold;
            box-shadow: 0 4px 16px rgba(26,35,126,0.15);
        }
        .node.level-1 {
            width: 200px !important;
            height: 60px !important;
            font-size: 1.1em;
            background: #ff9800;
            color: #fff;
            font-weight: 600;
            border-radius: 16px;
            box-shadow: 0 2px 8px rgba(255,152,0,0.10);
        }
        .node.level-2 {
            width: 180px !important;
            height: 45px !important;
            font-size: 1em;
            background: #fffde7;
            color: #333;
            border-radius: 20px;
            font-weight: 500;
            box-shadow: 0 2px 8px rgba(255,235,59,0.10);
        }
    </style>
</head>
<body>

    <div class="top-bar">
        <span class="menu-icon">‚ò∞</span>
        <span class="title">Learning about Large Language...</span>
        <div class="user-avatar">R</div>
        <button class="share-btn">Share</button>
        <div class="action-icons"><span>‚ñ∂Ô∏è</span><span>üí¨</span><span>üôÇ</span><span>üíæ</span></div>
    </div>

    <div class="main-content" id="mainContent">
        <div id="mindmap-container">
            <svg id="mindmap-svg"></svg>
        </div>
    </div>

    <div class="bottom-toolbar">
        <div class="dropdown">Learning abou... ‚ñº</div>
        <div class="zoom-level-display" id="zoomLevelDisplay">100%</div>
        <button class="tool-btn" id="exportMarkdownBtn" title="Export Markdown">üì§</button>
        <button class="tool-btn" id="importMarkdownBtn" title="Import Markdown">üì•</button>
        <button class="tool-btn" id="rearrangeNodesBtn" title="Rearrange Nodes">üîÉ</button>
        <div class="tools">
            <button class="tool-btn" id="addNodeBtn" title="Add Node">‚ûï</button>
            <button class="tool-btn" title="Link">üîó</button>
            <button class="tool-btn" title="Shape">‚ñ≠</button>
            <button class="tool-btn" title="Image">üñºÔ∏è</button>
            <button class="tool-btn" title="Text Style">Aa</button>
            <button class="tool-btn" title="Magic Wand">‚ú®</button> <!-- This one calls openLlmChatModal -->
        </div>
    </div>

    <div id="notesModal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeNotesModal()">√ó</span>
            <h2>Edit Node Details</h2>
            <input type="hidden" id="notesNodeId">
            <label for="nodeNameInput">Name:</label>
            <input type="text" id="nodeNameInput" placeholder="Enter node name...">
            <label for="nodeDescriptionTextarea">Description:</label>
            <textarea id="nodeDescriptionTextarea" placeholder="Enter description (notes) here..." style="height: 150px;"></textarea>
            <div class="modal-buttons">
                <button onclick="closeNotesModal()" class="cancel-btn">Cancel</button>
                <button onclick="saveNodeDetails()">Save Details</button>
            </div>
        </div>
    </div>

    <div id="llmChatModal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeLlmChatModal()">√ó</span>
            <h2>LLM Chat (Node: <span id="llmChatNodeName"></span>)</h2>
            <input type="hidden" id="llmChatNodeId">
            <div id="llmChatArea" class="chat-area" style="height: 250px;">
                <!-- Chat messages will appear here -->
            </div>
            <textarea id="llmChatInput" placeholder="Ask something about this node..." style="width: 95%; height: 80px; margin-top:10px; margin-bottom: 10px;"></textarea>
            <div class="modal-buttons">
                <button onclick="closeLlmChatModal()" class="cancel-btn">Close</button>
                <button onclick="sendLlmChatMessage()">Send</button>
            </div>
        </div>
    </div>

    <div id="markdownModal" class="modal"> <div class="modal-content"> <span class="close-btn" onclick="this.parentElement.parentElement.style.display='none'">√ó</span><h2>Markdown Import/Export</h2> <!-- ... Markdown Modal ... --> <button onclick="this.parentElement.parentElement.style.display='none'">Close</button></div></div>

    <script>
        const mainContent = document.getElementById('mainContent');
        const mindmapContainer = document.getElementById('mindmap-container');
        
        const notesModal = document.getElementById('notesModal');
        const notesNodeIdInput = document.getElementById('notesNodeId');
        const nodeNameInput = document.getElementById('nodeNameInput');
        const nodeDescriptionTextarea = document.getElementById('nodeDescriptionTextarea');

        const llmChatModal = document.getElementById('llmChatModal');
        const llmChatNodeIdInput = document.getElementById('llmChatNodeId');
        const llmChatNodeNameDisplay = document.getElementById('llmChatNodeName');
        const llmChatArea = document.getElementById('llmChatArea');
        const llmChatInput = document.getElementById('llmChatInput');

        const markdownModal = document.getElementById('markdownModal');

        let nodes = [];
        let nodeIdCounter = 0;
        let currentZoom = 1;
        let panX = 0;
        let panY = 0;
        const DRAG_THRESHOLD = 5; 

        const defaultNodes = [ 
            { id: 'llm_main', text: 'Learning about Large Language Models (LLMs)', x: 750, y: 500, color: '#2c3e50', textColor: '#fff', width: 220, height: 70, parentId: null, notes: 'Central topic about LLMs.', isCollapsed: false },
            { id: 'conclusion', text: 'Conclusion', x: 450, y: 200, color: '#8e44ad', textColor: '#fff', width: 150, parentId: 'llm_main', notes: '', isCollapsed: false },
            { id: 'conc_overview', text: 'Overview', x: 200, y: 150, color: '#9b59b6', textColor: '#fff', width: 220, parentId: 'conclusion', notes: 'Understanding LLMs requires a deep dive...\nFamiliarity with specific models...', isCollapsed: false },
            { id: 'ethical', text: 'Ethical Considerations', x: 450, y: 500, color: '#16a085', textColor: '#fff', width: 180, parentId: 'llm_main', notes: '', isCollapsed: false },
            { id: 'eth_overview', text: 'Overview', x: 200, y: 400, color: '#1abc9c', textColor: '#fff', width: 220, parentId: 'ethical', notes: 'The deployment of LLMs raises several ethical concerns.', isCollapsed: false },
            { id: 'eth_bias', text: 'Bias', x: 200, y: 500, color: '#1abc9c', textColor: '#fff', width: 220, parentId: 'ethical', notes: 'LLMs can inadvertently perpetuate biases...\nA study found that GPT-3 may exhibit gender bias...', isCollapsed: false },
            { id: 'eth_misinfo', text: 'Misinformation', x: 200, y: 600, color: '#1abc9c', textColor: '#fff', width: 220, parentId: 'ethical', notes: 'LLMs can generate human-like text...\nPotential misuse of GPT-3 for creating misleading articles...', isCollapsed: false },
            { id: 'apps', text: 'Applications of LLMs', x: 450, y: 800, color: '#27ae60', textColor: '#fff', width: 180, parentId: 'llm_main', notes: '', isCollapsed: false },
            { id: 'apps_overview', text: 'Overview', x: 200, y: 700, color: '#2ecc71', textColor: '#fff', width: 220, parentId: 'apps', notes: 'LLMs have found applications across various industries and tasks.', isCollapsed: false },
            { id: 'apps_content', text: 'Content Creation', x: 200, y: 800, color: '#2ecc71', textColor: '#fff', width: 220, parentId: 'apps', notes: 'Tools like Jasper use GPT-3 to help marketers...', isCollapsed: false },
            { id: 'apps_support', text: 'Customer Support', x: 200, y: 900, color: '#2ecc71', textColor: '#fff', width: 220, parentId: 'apps', notes: 'Companies like Drift employ LLMs to power chatbots...\nChatbots handle customer inquiries...', isCollapsed: false },
            { id: 'apps_translate', text: 'Language Translation', x: 200, y: 1000, color: '#2ecc71', textColor: '#fff', width: 220, parentId: 'apps', notes: 'Google Translate utilizes transformer models...\nMakes translation more accurate...', isCollapsed: false },
            { id: 'architecture', text: 'Architecture of LLMs', x: 1050, y: 350, color: '#d35400', textColor: '#fff', width: 180, parentId: 'llm_main', notes: '', isCollapsed: false },
            { id: 'arch_overview', text: 'LLMs Overview', x: 1300, y: 250, color: '#e67e22', textColor: '#fff', width: 220, parentId: 'architecture', notes: 'LLMs are built on transformer architecture...\nThey rely on self-attention mechanisms...', isCollapsed: false },
            { id: 'arch_gpt3', text: 'GPT-3', x: 1300, y: 350, color: '#e67e22', textColor: '#fff', width: 220, parentId: 'architecture', notes: 'Comprises 175 billion parameters...\nUtilizes a decoder-only transformer architecture...\nGenerates coherent and contextually relevant text...', isCollapsed: false },
            { id: 'arch_bert', text: 'BERT', x: 1300, y: 450, color: '#e67e22', textColor: '#fff', width: 220, parentId: 'architecture', notes: 'Employs a bidirectional transformer architecture...\nUnderstands the context of words in relation to all other words...\nUseful for tasks like question answering...', isCollapsed: false },
            { id: 'training', text: 'Training Processes', x: 1050, y: 650, color: '#f39c12', textColor: '#fff', width: 180, parentId: 'llm_main', notes: '', isCollapsed: false },
            { id: 'train_overview', text: 'Overview', x: 1300, y: 550, color: '#f1c40f', textColor: '#000', width: 220, parentId: 'training', notes: 'LLMs undergo extensive training on diverse datasets...', isCollapsed: false },
            { id: 'train_pre', text: 'Pre-training', x: 1300, y: 650, color: '#f1c40f', textColor: '#000', width: 220, parentId: 'training', notes: 'Involves unsupervised learning...\nThe model predicts the next word in a sentence...\nGPT-3 was trained on a dataset...', isCollapsed: false },
            { id: 'train_fine', text: 'Fine-tuning', x: 1300, y: 750, color: '#f1c40f', textColor: '#000', width: 220, parentId: 'training', notes: 'Models can be fine-tuned on specific tasks...\nBERT can be fine-tuned on SQuAD...', isCollapsed: false },
        ];

        const LEVEL_COLORS = [ 
            { bg: '#2c3e50', text: '#fff' },    
            { bg: '#4A90E2', text: '#fff' },    
            { bg: '#7ED321', text: '#000' },    
            { bg: '#F5A623', text: '#000' },    
            { bg: '#BD10E0', text: '#fff' },    
            { bg: '#D0021B', text: '#fff' },    
            { bg: '#417505', text: '#fff' }     
        ];

        function initMindmap() {
            nodes = defaultNodes.map(n => ({
                ...n, 
                width: n.width || 150,
                height: n.height || (n.text.split('\n').length * 20 + 40),
                isCollapsed: n.isCollapsed === undefined ? false : n.isCollapsed 
            }));
            nodeIdCounter = nodes.reduce((maxId, node) => {
                const numericId = parseInt(String(node.id).split('-').pop());
                return isNaN(numericId) ? maxId : Math.max(maxId, numericId);
            }, nodes.length);

            const mainNode = findNodeById('llm_main') || (nodes.length > 0 ? nodes.find(n => !n.parentId) || nodes[0] : null);
            if (mainNode) {
                panX = (mainContent.clientWidth / 2) - (mainNode.x * currentZoom + (mainNode.width * currentZoom)/2) ;
                panY = (mainContent.clientHeight / 2) - (mainNode.y * currentZoom + (mainNode.height* currentZoom)/2);
            } else {
                 panX = 50; panY = 50;
            }
            applyTransform();
            renderMindmap(); 
            resolveNodeOverlaps(); 
        }
        
        function findNodeById(id) { return nodes.find(node => node.id === id); }
        function getChildren(parentId) { return nodes.filter(node => node.parentId === parentId); }
        
        function getNodeLevel(nodeId) {
            let level = 0;
            let currentNode = findNodeById(nodeId);
            while (currentNode && currentNode.parentId) {
                level++;
                currentNode = findNodeById(currentNode.parentId);
                if (!currentNode) break; 
            }
            return level;
        }

        function assignNodeStyleByLevel(node, level) {
            const styleIndex = node.parentId ? level : Math.max(0, level -1); 
            const style = LEVEL_COLORS[Math.min(styleIndex, LEVEL_COLORS.length - 1)];
            node.color = style.bg;
            node.textColor = style.text;
        }
        
        function getVisibleNodes() {
            const visible = [];
            function recurse(nodeId) { 
                const node = findNodeById(nodeId);
                if (!node) return;
                visible.push(node);
                if (!node.isCollapsed) {
                    getChildren(nodeId).forEach(child => recurse(child.id));
                }
            }
            nodes.filter(n => !n.parentId).forEach(rootNode => recurse(rootNode.id));
            return visible;
        }

        function renderMindmap() {
            const existingSvg = document.getElementById('mindmap-svg');
            mindmapContainer.innerHTML = '';
            mindmapContainer.appendChild(existingSvg); 

            const nodesToRender = getVisibleNodes();
            
            nodesToRender.forEach(node => {
                const nodeEl = document.createElement('div');
                nodeEl.classList.add('node');
                nodeEl.id = `node-${node.id}`;
                nodeEl.style.left = `${node.x}px`;
                nodeEl.style.top = `${node.y}px`;
                nodeEl.style.backgroundColor = node.color;
                nodeEl.style.color = node.textColor || '#000';
                nodeEl.style.width = `${node.width}px`;
                nodeEl.style.height = `${node.height}px`;

                if (window.selectedElement && 
                    window.selectedElement.type === 'node' && 
                    window.selectedElement.id === node.id) {
                    nodeEl.classList.add('node-selected');
                }

                const contentWrapper = document.createElement('div');
                contentWrapper.classList.add('node-content-wrapper');
                const textEl = document.createElement('div');
                textEl.classList.add('node-text');
                textEl.innerHTML = node.text.replace(/\n/g, '<br>');
                contentWrapper.appendChild(textEl);
                nodeEl.appendChild(contentWrapper);

                nodeEl.addEventListener('mouseenter', () => {
                    if (!window.selectedElement && !nodeEl.classList.contains('node-dragging-active')) {
                        nodeEl.classList.add('node-highlighted');
                    }
                });

                nodeEl.addEventListener('mouseleave', () => {
                    if (!window.selectedElement) {
                        nodeEl.classList.remove('node-highlighted');
                    }
                });

                nodeEl.addEventListener('click', (e) => {
                    if (e.target === nodeEl || e.target.closest('.node-content-wrapper')) {
                         if (e.target.classList.contains('magic-icon') || e.target.classList.contains('node-toggle')) {
                            return; 
                        }
                        selectElement('node', node.id);
                        e.stopPropagation();
                    }
                });

                nodeEl.addEventListener('dblclick', (e) => {
                     if (e.target === nodeEl || e.target.closest('.node-content-wrapper')) {
                        if (e.target.classList.contains('magic-icon') || e.target.classList.contains('node-toggle')) {
                            return; 
                        }
                        openNotesModal(node.id);
                        e.stopPropagation();
                    }
                });

                const magicIconEl = document.createElement('span');
                magicIconEl.classList.add('magic-icon');
                magicIconEl.textContent = '‚ú®';
                magicIconEl.onclick = (e) => {
                    e.stopPropagation();
                    openLlmChatModal(node.id);
                };
                nodeEl.appendChild(magicIconEl);

                const children = getChildren(node.id);
                if (children.length > 0) {
                    const toggleBtn = document.createElement('div');
                    toggleBtn.classList.add('node-toggle');
                    toggleBtn.innerHTML = node.isCollapsed ? children.length : '‚Äì';
                    toggleBtn.title = node.isCollapsed ? "Expand ("+children.length+")" : "Collapse";
                    toggleBtn.onclick = (e) => {
                        e.stopPropagation();
                        toggleCollapse(node.id);
                    };
                    nodeEl.appendChild(toggleBtn);
                }

                const level = getNodeLevel(node.id);
                nodeEl.classList.add(`level-${level}`);

                mindmapContainer.appendChild(nodeEl);
            });
            renderConnections();
        }

        function renderConnections() {
            const mindmapSvg = document.getElementById('mindmap-svg');
            mindmapSvg.innerHTML = ''; 

            const nodesToRender = getVisibleNodes();
            nodesToRender.forEach(node => {
                if (node.parentId) {
                    const parentNode = findNodeById(node.parentId);
                    if (parentNode && nodesToRender.includes(parentNode)) { 
                        drawConnection(parentNode, node, mindmapSvg);
                    }
                }
            });
        }

        function toggleCollapse(nodeId) {
            const node = findNodeById(nodeId);
            if (node) {
                node.isCollapsed = !node.isCollapsed;
                if (document.getElementById('rearrangeNodesBtn').classList.contains('active-layout')) {
                    applyTreeLayout(); 
                } else {
                    renderMindmap(); 
                }
            }
        }
        
        function drawConnection(parentNode, childNode, svgEl) {
            const pX = parentNode.x + parentNode.width / 2;
            const pY = parentNode.y + parentNode.height / 2;
            const cX = childNode.x + childNode.width / 2;
            const cY = childNode.y + childNode.height / 2;
            const deltaX = (cX - pX) * 0.5;
            const d = `M ${pX} ${pY} C ${pX + deltaX} ${pY}, ${cX - deltaX} ${cY}, ${cX} ${cY}`;
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', d);
            path.setAttribute('stroke', parentNode.color || '#7f8c8d');
            path.setAttribute('stroke-width', '3');
            path.setAttribute('fill', 'none');
            path.setAttribute('opacity', '0.85');
            path.id = `path-${parentNode.id}-${childNode.id}`;
            
            if (window.selectedElement && 
                window.selectedElement.type === 'connection' && 
                window.selectedElement.parentId === parentNode.id &&
                window.selectedElement.childId === childNode.id) {
                path.classList.add('path-selected');
            }
            
            path.addEventListener('click', (e) => {
                selectElement('connection', null, parentNode.id, childNode.id);
                e.stopPropagation();
            });
            
            path.addEventListener('mouseenter', () => {
                if (window.selectedElement) return;
                
                document.querySelectorAll('.node-highlighted').forEach(el => el.classList.remove('node-highlighted'));
                document.querySelectorAll('.path-highlighted').forEach(el => {
                    if (el !== path) el.classList.remove('path-highlighted');
                });
                
                path.classList.add('path-highlighted');
                window.highlightedElement = { type: 'connection', parentId: parentNode.id, childId: childNode.id };
            });
            
            path.addEventListener('mouseleave', () => {
                if (window.selectedElement) return;
                
                if (!document.querySelector('.node:hover')) {
                    path.classList.remove('path-highlighted');
                    window.highlightedElement = null;
                }
            });
            
            svgEl.appendChild(path);
        }

        document.getElementById('addNodeBtn').addEventListener('click', () => {
            nodeIdCounter++;
            const newNodeId = `custom-${nodeIdCounter}`;
            const mainContentRect = mainContent.getBoundingClientRect();
            const viewCenterX = (mainContentRect.width / 2 - panX) / currentZoom;
            const viewCenterY = (mainContentRect.height / 2 - panY) / currentZoom;

            let parentIdForNewNode = null;
            let newX = Math.max(0, viewCenterX - 75);
            let newY = Math.max(0, viewCenterY - 25);

            if(window.selectedElement && window.selectedElement.type === 'node'){
                const selectedNode = findNodeById(window.selectedElement.id);
                if(selectedNode){
                    parentIdForNewNode = selectedNode.id;
                    newX = selectedNode.x + selectedNode.width + 50; 
                    newY = selectedNode.y + selectedNode.height / 2 - 25; 
                }
            }

            const newNode = {
                id: newNodeId, text: 'New Node', notes: '',
                x: newX, y: newY,
                width: 150, height: 50,
                parentId: parentIdForNewNode, isCollapsed: false
            };
            const level = getNodeLevel(newNode.id); 
            assignNodeStyleByLevel(newNode, level); 

            nodes.push(newNode);
            renderMindmap();
            resolveNodeOverlaps();
        });
        
        function openNotesModal(nodeId) { 
            const node = findNodeById(nodeId);
            if (!node) return;
            notesNodeIdInput.value = nodeId;
            nodeNameInput.value = node.text;
            nodeDescriptionTextarea.value = node.notes;
            notesModal.style.display = 'flex';
        }
        function closeNotesModal() { notesModal.style.display = 'none'; }
        function saveNodeDetails() { 
            const nodeId = notesNodeIdInput.value;
            const node = findNodeById(nodeId);
            if (node) {
                node.text = nodeNameInput.value;
                node.notes = nodeDescriptionTextarea.value;
                const nameLines = node.text.split('\n').length;
                const newHeight = Math.max(50, nameLines * 20 + 30 + (node.notes ? 10 : 0) ); 
                const heightChanged = node.height !== newHeight;
                node.height = newHeight;
                renderMindmap();
                if (heightChanged) resolveNodeOverlaps(); 
            }
            closeNotesModal();
        }
        
        function openLlmChatModal(nodeId) {
            const node = findNodeById(nodeId);
            if (!node) return;
            llmChatNodeIdInput.value = nodeId;
            llmChatNodeNameDisplay.textContent = node.text.length > 20 ? node.text.substring(0, 17) + "..." : node.text;
            llmChatArea.innerHTML = `<p><em>Chatting about: ${node.text}</em></p>`; 
            llmChatInput.value = '';
            llmChatModal.style.display = 'flex';
        }
        function closeLlmChatModal() { llmChatModal.style.display = 'none'; }
        function sendLlmChatMessage() {
            const nodeId = llmChatNodeIdInput.value;
            const node = findNodeById(nodeId);
            const messageText = llmChatInput.value.trim();
            if (!node || !messageText) return;

            const userMsgEl = document.createElement('p');
            userMsgEl.innerHTML = `<strong>You:</strong> ${messageText}`;
            llmChatArea.appendChild(userMsgEl);
            
            setTimeout(() => {
                const llmResponseEl = document.createElement('p');
                llmResponseEl.innerHTML = `<strong>LLM:</strong> Thanks for asking about "${messageText}" related to "${node.text}". I'm still learning!`;
                llmChatArea.appendChild(llmResponseEl);
                llmChatArea.scrollTop = llmChatArea.scrollHeight; 
            }, 500);

            llmChatInput.value = '';
            llmChatArea.scrollTop = llmChatArea.scrollHeight;
        }
        
        function openMarkdownModal() { markdownModal.style.display = 'flex'; }
        function exportToMarkdown() { console.log("Exporting to Markdown - Placeholder"); }
        function importFromMarkdown(markdown) { console.log("Importing from Markdown - Placeholder"); }


        let isPanning = false; let panStartPointerX, panStartPointerY;
        mainContent.addEventListener('mousedown', (e) => {
            if (e.target === mainContent || e.target.id === 'mindmap-container' || e.target.closest('#mindmap-svg')) {
                isPanning = true; mainContent.classList.add('panning');
                panStartPointerX = e.clientX; panStartPointerY = e.clientY;
            }
        });
        document.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            const dx = e.clientX - panStartPointerX; const dy = e.clientY - panStartPointerY;
            panX += dx; panY += dy;
            panStartPointerX = e.clientX; panStartPointerY = e.clientY;
            applyTransform();
        });
        document.addEventListener('mouseup', () => {
            if (isPanning) { isPanning = false; mainContent.classList.remove('panning');}
        });

        mainContent.addEventListener('wheel', (e) => { 
            e.preventDefault(); const zoomSpeed = 0.05; 
            const oldZoom = currentZoom;
            if (e.deltaY < 0) { currentZoom = Math.min(3, currentZoom + zoomSpeed); } 
            else { currentZoom = Math.max(0.2, currentZoom - zoomSpeed); }
            const rect = mainContent.getBoundingClientRect();
            const mouseX = e.clientX - rect.left; const mouseY = e.clientY - rect.top;
            const mapXBeforeZoom = (mouseX - panX) / oldZoom; const mapYBeforeZoom = (mouseY - panY) / oldZoom;
            panX = mouseX - (mapXBeforeZoom * currentZoom); panY = mouseY - (mapYBeforeZoom * currentZoom);
            applyTransform(); updateZoomDisplay();
        });

        function applyTransform() { mindmapContainer.style.transform = `translate(${panX}px, ${panY}px) scale(${currentZoom})`; }
        function updateZoomDisplay() { document.getElementById('zoomLevelDisplay').textContent = `${Math.round(currentZoom * 100)}%`; }
        
        function makeModalDraggable(modalElement) { 
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            const header = modalElement.querySelector("h2") || modalElement.firstElementChild;

            if (header) {
                header.style.cursor = 'move';
                header.onmousedown = dragMouseDown;
            } else {
                modalElement.style.cursor = 'move';
                modalElement.onmousedown = dragMouseDown;
            }

            function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }

            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                modalElement.style.top = (modalElement.offsetTop - pos2) + "px";
                modalElement.style.left = (modalElement.offsetLeft - pos1) + "px";
                const rect = modalElement.getBoundingClientRect();
                if (rect.left < 0) modalElement.style.left = "0px";
                if (rect.top < 0) modalElement.style.top = "0px";
                if (rect.right > window.innerWidth) modalElement.style.left = (window.innerWidth - rect.width) + "px";
                if (rect.bottom > window.innerHeight) modalElement.style.top = (window.innerHeight - rect.height) + "px";
            }

            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }
        makeModalDraggable(notesModal.querySelector('.modal-content')); 
        makeModalDraggable(llmChatModal.querySelector('.modal-content'));
        makeModalDraggable(markdownModal.querySelector('.modal-content'));

        // --- MODIFIED Node Dragging Logic ---
        mindmapContainer.addEventListener('mousedown', function(e) {
            let targetElement = e.target;
            while(targetElement && targetElement !== mindmapContainer) {
                if (targetElement.classList.contains('magic-icon') || targetElement.classList.contains('node-toggle')) {
                    return; 
                }
                if (targetElement.classList.contains('node')) {
                    break; 
                }
                targetElement = targetElement.parentElement;
            }

            if (targetElement && targetElement.classList.contains('node')) {
                const nodeEl = targetElement;
                const nodeId = nodeEl.id.replace('node-', '');
                const nodeData = findNodeById(nodeId);
                if (!nodeData) return;

                e.preventDefault(); 
                e.stopPropagation(); 

                const mainRect = mainContent.getBoundingClientRect();
                const startPointerScreenX = e.clientX;
                const startPointerScreenY = e.clientY;
                const startPointerMapX = (startPointerScreenX - mainRect.left - panX) / currentZoom;
                const startPointerMapY = (startPointerScreenY - mainRect.top - panY) / currentZoom;
                const initialNodeMapX = nodeData.x;
                const initialNodeMapY = nodeData.y;

                let isDragging = false;
                const DRAG_THRESHOLD_SQUARED = DRAG_THRESHOLD * DRAG_THRESHOLD;

                function onMouseMove(moveEvent) {
                    moveEvent.preventDefault(); 

                    const currentPointerScreenX = moveEvent.clientX;
                    const currentPointerScreenY = moveEvent.clientY;

                    if (!isDragging) {
                        const dxScreen = currentPointerScreenX - startPointerScreenX;
                        const dyScreen = currentPointerScreenY - startPointerScreenY;
                        if ((dxScreen * dxScreen + dyScreen * dyScreen) > DRAG_THRESHOLD_SQUARED) {
                            isDragging = true;
                            nodeEl.classList.add('node-dragging-active'); // *** ADD CLASS ***
                        } else {
                            return; 
                        }
                    }
                    
                    const currentPointerMapX = (currentPointerScreenX - mainRect.left - panX) / currentZoom;
                    const currentPointerMapY = (currentPointerScreenY - mainRect.top - panY) / currentZoom;
                    const deltaMapX = currentPointerMapX - startPointerMapX;
                    const deltaMapY = currentPointerMapY - startPointerMapY;
                    const newMapX = initialNodeMapX + deltaMapX;
                    const newMapY = initialNodeMapY + deltaMapY;

                    // *** CORRECTED ORDER OF UPDATES ***
                    // 1. Update the node's data in the `nodes` array FIRST
                    nodeData.x = newMapX;
                    nodeData.y = newMapY;

                    // 2. Update the node's visual style (DOM element)
                    nodeEl.style.left = `${newMapX}px`;
                    nodeEl.style.top = `${newMapY}px`;

                    // 3. Update connected SVG paths
                    const mindmapSvg = document.getElementById('mindmap-svg');
                    if (nodeData.parentId) {
                        const parentNode = findNodeById(nodeData.parentId);
                        const parentNodeEl = parentNode ? document.getElementById(`node-${parentNode.id}`) : null;
                        if (parentNode && parentNodeEl) { 
                            const pathId = `path-${parentNode.id}-${nodeData.id}`;
                            const pathElement = mindmapSvg.querySelector(`#${CSS.escape(pathId)}`);
                            if (pathElement) {
                                const pX = parentNode.x + parentNode.width / 2;
                                const pY = parentNode.y + parentNode.height / 2;
                                const cX = nodeData.x + nodeData.width / 2; 
                                const cY = nodeData.y + nodeData.height / 2; 
                                const dPathX = (cX - pX) * 0.5;
                                const d = `M ${pX} ${pY} C ${pX + dPathX} ${pY}, ${cX - dPathX} ${cY}, ${cX} ${cY}`;
                                pathElement.setAttribute('d', d);
                            }
                        }
                    }

                    const children = getChildren(nodeData.id);
                    children.forEach(childNode => {
                        const childNodeEl = document.getElementById(`node-${childNode.id}`);
                        if (childNodeEl) {
                            const pathId = `path-${nodeData.id}-${childNode.id}`;
                            const pathElement = mindmapSvg.querySelector(`#${CSS.escape(pathId)}`);
                            if (pathElement) {
                                const pX = nodeData.x + nodeData.width / 2; 
                                const pY = nodeData.y + nodeData.height / 2; 
                                const cX = childNode.x + childNode.width / 2;
                                const cY = childNode.y + childNode.height / 2;
                                const dPathX = (cX - pX) * 0.5;
                                const d = `M ${pX} ${pY} C ${pX + dPathX} ${pY}, ${cX - dPathX} ${cY}, ${cX} ${cY}`;
                                pathElement.setAttribute('d', d);
                            }
                        }
                    });
                }

                function onMouseUp(upEvent) {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    if (isDragging) {
                       nodeEl.classList.remove('node-dragging-active'); // *** REMOVE CLASS ***
                    }
                }

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }
        });
        // --- END OF MODIFIED Node Dragging Logic ---

        function resolveNodeOverlaps() { 
            const visibleNodes = getVisibleNodes();
            if (visibleNodes.length < 2) return;

            const spacing = 50; 
            let iterations = 0;
            const maxIterations = 30 * visibleNodes.length; 
            let collisionsFoundThisIteration;
            let nodesMoved = false;

            do {
                collisionsFoundThisIteration = false;
                for (let i = 0; i < visibleNodes.length; i++) {
                    for (let j = i + 1; j < visibleNodes.length; j++) {
                        const nodeA = visibleNodes[i];
                        const nodeB = visibleNodes[j];

                        const A_left = nodeA.x; const A_right = nodeA.x + nodeA.width;
                        const A_top = nodeA.y; const A_bottom = nodeA.y + nodeA.height;
                        const B_left = nodeB.x; const B_right = nodeB.x + nodeB.width;
                        const B_top = nodeB.y; const B_bottom = nodeB.y + nodeB.height;

                        const overlapX = Math.max(0, Math.min(A_right + spacing, B_right + spacing) - Math.max(A_left, B_left));
                        const overlapY = Math.max(0, Math.min(A_bottom + spacing, B_bottom + spacing) - Math.max(A_top, B_top));

                        if (overlapX > 0 && overlapY > 0) {
                            collisionsFoundThisIteration = true; nodesMoved = true;
                            
                            const centerAx = nodeA.x + nodeA.width / 2; const centerAy = nodeA.y + nodeA.height / 2;
                            const centerBx = nodeB.x + nodeB.width / 2; const centerBy = nodeB.y + nodeB.height / 2;
                            const pushFactor = 0.5; 

                            if (overlapX < overlapY) { 
                                const move = (centerAx < centerBx ? -overlapX : overlapX) * pushFactor;
                                if (!isAncestor(nodeA, nodeB) && !isAncestor(nodeB, nodeA)) {
                                    nodeA.x += move; nodeB.x -= move;
                                } else if (isAncestor(nodeA, nodeB)) { nodeB.x -= move * 2; } 
                                else { nodeA.x += move * 2; }
                            } else { 
                                const move = (centerAy < centerBy ? -overlapY : overlapY) * pushFactor;
                                 if (!isAncestor(nodeA, nodeB) && !isAncestor(nodeB, nodeA)) {
                                    nodeA.y += move; nodeB.y -= move;
                                } else if (isAncestor(nodeA, nodeB)) { nodeB.y -= move * 2; } 
                                else { nodeA.y += move * 2; }
                            }
                        }
                    }
                }
                iterations++;
            } while (collisionsFoundThisIteration && iterations < maxIterations);
            
            if (nodesMoved) { renderMindmap(); }
        }

        function isAncestor(potentialAncestorNode, node) { 
            let current = node;
            while (current && current.parentId) { 
                if (current.parentId === potentialAncestorNode.id) return true;
                current = findNodeById(current.parentId);
            }
            return false;
        }

        document.getElementById('rearrangeNodesBtn').addEventListener('click', () => {
            applyTreeLayout();
            document.getElementById('rearrangeNodesBtn').classList.add('active-layout'); 
        });
        
        function applyTreeLayout() {
            const HORIZONTAL_SPACING = 200; 
            const VERTICAL_SPACING = 20;   
            let initialX = 50;
            let yPos = 50; 

            function layoutSubtree(nodeId, currentX, parentCenterY, level) {
                const node = findNodeById(nodeId);
                if (!node) return { height: 0, y: parentCenterY };

                node.x = currentX;

                const children = getChildren(nodeId).filter(c => getVisibleNodes().includes(c)); 
                
                if (!children.length || node.isCollapsed) {
                    node.y = parentCenterY - node.height / 2; 
                    return { height: node.height, y: node.y };
                }

                let childrenTotalHeight = 0;
                children.forEach(child => childrenTotalHeight += child.height); 
                childrenTotalHeight += (children.length - 1) * VERTICAL_SPACING;

                let childStartY = parentCenterY - childrenTotalHeight / 2;
                let maxSubtreeHeightForParent = 0;

                children.forEach(child => {
                    const childLayoutInfo = layoutSubtree(child.id, currentX + HORIZONTAL_SPACING, childStartY + child.height / 2, level + 1);
                    child.y = childStartY; 
                    childStartY += child.height + VERTICAL_SPACING;
                    maxSubtreeHeightForParent = Math.max(maxSubtreeHeightForParent, childLayoutInfo.height);
                });
                
                if (children.length > 0) {
                    const firstChild = children[0];
                    const lastChild = children[children.length - 1];
                    const childrenBlockMidY = firstChild.y + ((lastChild.y + lastChild.height) - firstChild.y) / 2;
                    node.y = childrenBlockMidY - node.height / 2;
                } else {
                     node.y = parentCenterY - node.height / 2;
                }
                return { height: Math.max(node.height, childrenTotalHeight), y: node.y };
            }

            const rootNodes = nodes.filter(n => !n.parentId);
            rootNodes.forEach(root => {
                const subtreeInfo = layoutSubtree(root.id, initialX, yPos + root.height / 2, 0); 
                yPos += subtreeInfo.height + VERTICAL_SPACING * 3; 
            });
            
            if (rootNodes.length > 0) {
                 const firstRoot = rootNodes[0];
                 panX = (mainContent.clientWidth / 2) - (firstRoot.x * currentZoom + (firstRoot.width * currentZoom)/2) - 100*currentZoom; 
                 panY = (mainContent.clientHeight / 2) - (firstRoot.y * currentZoom + (firstRoot.height* currentZoom)/2);
                 applyTransform();
            }

            renderMindmap();
            console.log("Tree layout applied.");
        }

        function selectElement(type, nodeId, parentId, childId) {
            clearSelection();
            
            if (type === 'node') {
                window.selectedElement = { type: 'node', id: nodeId };
                const nodeEl = document.getElementById(`node-${nodeId}`);
                if (nodeEl) {
                    nodeEl.classList.add('node-selected');
                }
            } else if (type === 'connection') {
                window.selectedElement = { type: 'connection', parentId: parentId, childId: childId };
                const pathEl = document.getElementById(`path-${parentId}-${childId}`);
                if (pathEl) {
                    pathEl.classList.add('path-selected');
                }
            }
            document.getElementById('rearrangeNodesBtn').classList.remove('active-layout');
        }
        
        function clearSelection() {
            document.querySelectorAll('.node-selected').forEach(el => el.classList.remove('node-selected'));
            document.querySelectorAll('.path-selected').forEach(el => el.classList.remove('path-selected'));
            window.selectedElement = null;
        }
        
        mindmapContainer.addEventListener('click', (e) => {
            if (e.target === mindmapContainer || e.target.id === 'mindmap-svg') {
                clearSelection();
                 document.getElementById('rearrangeNodesBtn').classList.remove('active-layout');
            }
        });
        
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                const activeModal = document.querySelector('.modal[style*="display: flex"]');
                if (activeModal && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) {
                    return; 
                }

                const elementToDelete = window.selectedElement || window.highlightedElement;
                
                if (elementToDelete) {
                    if (elementToDelete.type === 'node') {
                        if (confirm(`Delete node "${findNodeById(elementToDelete.id)?.text}" and its children?`)) {
                            deleteNode(elementToDelete.id);
                            window.selectedElement = null;
                            window.highlightedElement = null;
                        }
                    } else if (elementToDelete.type === 'connection') {
                        if (confirm('Delete this connection?')) {
                            deleteConnection(elementToDelete.parentId, elementToDelete.childId);
                            window.selectedElement = null;
                            window.highlightedElement = null;
                        }
                    }
                }
            }
        });

        function deleteNode(nodeId) {
            function getAllChildIds(parentId) {
                const childIds = [];
                nodes.filter(n => n.parentId === parentId).forEach(child => {
                    childIds.push(child.id);
                    childIds.push(...getAllChildIds(child.id));
                });
                return childIds;
            }
            const childIdsToDelete = getAllChildIds(nodeId);
            nodes = nodes.filter(node => node.id !== nodeId && !childIdsToDelete.includes(node.id));
            renderMindmap();
        }
        
        function deleteConnection(parentId, childId) {
            const childNode = findNodeById(childId);
            if (childNode && childNode.parentId === parentId) {
                childNode.parentId = null;
                renderMindmap();
            }
        }

        initMindmap();
    </script>
</body>
</html>